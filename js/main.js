// Написати функцію, яка приймає 1 параметр. з тим, що передали перший раз і т. д. Все це із замиканнями, наприклад:
// sum(3) = 3
// sum(5) = 8
// sum(20) = 28

// [[ Environment ]] = Global Env
// ^ В момент СТВОРЕННЯ функції, до неї чіпляється силка
// на оточення в якому вона була створена. В даному випадку
// це глобальне оточення
function calcSum(memo = 0) {
    // В момент ВИКЛИКУ функції створюється ВЛАСНЕ оточення
    // (це також відноситься до циклів, if-else, switch, try-catch, звичайних блоків {}),
    // яке містить силку на оточення в якому вона була створена (Parent -> [[ Environment ]])
    // і спеціальний об'єкт Environment Record який містить в собі посилання
    // на всі створені змінні та функції в поточному оточенні.
    // Силка на батьківське оточення потрібна на випадок використання змінних, функцій які
    // були об'явлені зовні в ланцюгу доступних середовищ
    // ВЛАСНЕ середовище що буде створено при визові функції:
    // Lexical Environment = {
    //   Environment Record: { memo: 0, .... },
    //   Parent: Global Env
    // }

    // [[ Environment ]] = Env of calcSum
    return (num) => {
        // ВЛАСНЕ середовище що створиться при ВИКЛИКУ функції:
        // Lexical Environment = {
        //   Environment Record: { num: ..., .... },
        //   Parent: Env of calcSum
        // }
        // Таким чином, при визові, ця анонімна функція буде мати доступ
        // до змінних на функцій, які об'явлені в Env of calcSum та Global Env
        // Ланцюг: Env of this arrow anonymous function -> Env of calcSum -> Global Env
        // Цей ланцюг буде існувати в пам'яті, до тих пір поки буде існувати змінна в яку
        // буде записана ця анонімна функція.
        // В момент, коли змінній буде присвоєно інше значення (наприклад null) і під час
        // роботи скрипта не буде інших змінних які будуть вказувати на цю функцію - цей ланцюг буде видалено.
        return memo += num;
    };
}

const sum = calcSum();

console.log(sum(3));
console.log(sum(5));
console.log(sum(20));
